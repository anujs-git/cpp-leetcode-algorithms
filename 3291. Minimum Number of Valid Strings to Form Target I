struct TrieNode{
    TrieNode* child[26];
    bool isEnd;
    TrieNode() {
        for (int i = 0; i < 26; i++)
            child[i] = nullptr;
        isEnd = false;
    }
};

class Solution {
public:
    TrieNode* root;
    Solution() {
        root=new TrieNode();
    }
    
    void insert(string& word) {
        TrieNode* root1=root;
        for(int i=0;i<word.size();i++){
           int index=word[i]-'a';
           if(root1->child[index]==nullptr){
              root1->child[index]=new TrieNode();
              root1=root1->child[index];
           }
           else root1=root1->child[index];
        }
        root1->isEnd=true;
    }
    
    bool search(string word) {
        TrieNode* root1=root;
        for(int i=0;i<word.size();i++){
            int idx=word[i]-'a';
            if(root1->child[idx]==nullptr)return false;
            root1=root1->child[idx];
        }
        return root1->isEnd;
    }
    
    int minValidStrings(vector<string>& words, string target) {
       for(int i=0;i<words.size();i++)insert(words[i]);
       int n=target.size();
       vector<int> dp(n+1, n+1);
       dp[0]=0;
       for(int i=0;i<n;i++){
         TrieNode* node=root;
         for(int j=i;j<n;j++){
            int idx=target[j]-'a';
            if(node->child[idx]==nullptr)break;
            node=node->child[idx];
            dp[j+1]=min(dp[j+1],dp[i]+1);
         }
       }
       if(dp[n]>n)dp[n]=-1;
       return dp[n];

    }
    

};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
