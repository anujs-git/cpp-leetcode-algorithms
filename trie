struct TrieNode{
    TrieNode* child[26];
    bool isEnd;
    TrieNode(){
        for(int i=0;i<26;i++)child[i]=nullptr;
        isEnd=false;
    }
};
class Solution {
public:
    TrieNode* root;
    Solution(){
        root=new TrieNode();
    }
    void insert(string word){
        TrieNode* node=root;
        for(int i=0;i<word.size();i++){
            char ch=word[i];
            if(node->child[ch-'a']==nullptr)node->child[ch-'a']=new TrieNode();
            node=node->child[ch-'a'];
        }
        node->isEnd=true;
    }
    void dfs(TrieNode* node,string& ans,string temp){
        if(node==nullptr)return;
        if(node->isEnd){
            if(temp.size()>ans.size())ans=temp;
        }
        for(int i=0;i<26;i++){
            if(node->child[i]!=nullptr&&node->child[i]->isEnd){
                char ch=i+'a';
                dfs(node->child[i],ans,temp+ch);
            }
        }

    }
    string longestWord(vector<string>& words) {
        for(int i=0;i<words.size();i++)insert(words[i]);
        string ans="";
        TrieNode* node=root;
        dfs(node,ans,"");
        return ans;
    }
};
